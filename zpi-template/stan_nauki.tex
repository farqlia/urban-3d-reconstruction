\section{Stan wiedzy}

Unikalność projektu wynika z połączenia wielu rozwiązań które istnieją samodzielnie na rynku. Algorytm Structure-from-Motion \cite{Schonberger_2016_CVPR} jest popularną fotogrametryczną techniką uzyskiwania chmury punktów ze zbioru zdjęć i jego implementacja oferowana jest m. in. przez oprogramowanie COLMAP. 

W przypadku modelu 3D często stosowaną techniką są siatki, ale ich wadą jest niekompatybilność z algorytmami sztucznej inteligencji. Popularne są też rozwiązania wykorzystujące sieci neuronowe jak np. NeRF\cite{mildenhall2020nerfrepresentingscenesneural}, jednak długi czas trenowania, osiągający nawet parę dni, jest nieefektywny. Z tego powodu zdecydowano się na wykorzystanie algorytmu Gaussian Splatting\cite{kerbl3Dgaussians}, który buduje model sceny z tzw. gaussianów, które można interpretować jako punkty rozmyte. Istniejące adaptacje do skali urbanistycznej tego algorytmu to np. CityGaussian\cite{liu2024citygaussian}.

Ważnym krokiem jest również filtracja chmury punktów \cite{HAN2017103} w celu usunięcia odstających punktów lub tych nieistotnych dla wyników klasyfikacji. W tym obszarze znajdują się np. techniki statystyczne czy oparte na sąsiedztwie. 

Istniejące architektury sieci neuronowych dla zadania segmentacji są głównie przeznaczone dla scen zamkniętych lub pojedynczych obiektów. Popularnym rozwiązaniem jest PointNet\cite{qi2016pointnet} oraz jego następnik PointNet++\cite{qi2017pointnetdeephierarchicalfeature} oparte na wielowarstwowym perceptronie, jak i również bardziej skomplikowane rozwiązania jak KPConv\cite{thomas2019kpconvflexibledeformableconvolution} wykorzystujące konwolucje. Wyzwaniem dla projektu jest dostosowanie takich architektur do chmury punktów o wielkości rzędu milionów punktów.  

W przypadku renderowania istnieją rozwiązania przeznaczone zarówno do chmur punktów jak i do splatów, zaimplementowane często przy pomocy WebGL, jak \cite{splatviewer}. Wyzwanie stanowi jednak wydajne i efektywne przedstawienie milionów elementów, co wymaga skorzystania z GPU i niskopoziomowego pisania kodu. 

